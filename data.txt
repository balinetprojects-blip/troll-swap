/*eslint-disable @typescript-eslint/no-explicit-any */
'use client';

import dynamic from 'next/dynamic';
import type React from 'react';
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import Image from 'next/image';
import JSBI from 'jsbi';
import {
  Connection,
  PublicKey,
  ParsedAccountData,
  AccountInfo,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import { useWallet } from '@solana/wallet-adapter-react';
import { JupiterProvider, useJupiter } from '@jup-ag/react-hook';
import {
  getAssociatedTokenAddressSync,
  createTransferCheckedInstruction,
  getAccount,
  TOKEN_PROGRAM_ID,
} from '@solana/spl-token';


/* =========================
   Client-only wallet button
   ========================= */
const WalletButton = dynamic(
  async () => (await import('@solana/wallet-adapter-react-ui')).WalletMultiButton,
  { ssr: false }
);

/* =========
   ENV VARS
   ========= */
const RPC   = process.env.NEXT_PUBLIC_RPC_URL!;
const WS    = process.env.NEXT_PUBLIC_WS_URL;
const TROLL = process.env.NEXT_PUBLIC_TROLL_MINT!;
const SOL   = process.env.NEXT_PUBLIC_SOL_MINT!; // So1111...
const CLUSTER = process.env.NEXT_PUBLIC_SOLANA_CLUSTER || 'mainnet';
function solscanTxUrl(sig: string) {
  const suffix = CLUSTER === 'mainnet' ? '' : `?cluster=${CLUSTER}`;
  return `https://solscan.io/tx/${sig}${suffix}`;
}

/* ===================
   Helpers & Constants
   =================== */
const SOL_FEE_BUFFER = 0.0005;

function clamp(n: number, min: number, max: number) {
  return Math.min(max, Math.max(min, n));
}
function fmt(n: number, dp = 6) {
  return Number.isFinite(n) ? n.toFixed(dp) : '0';
}

/**
 * Read decimals from a parsed mint account without using `any`.
 */
async function getMintDecimals(connection: Connection, mintPk: PublicKey): Promise<number> {
  const info = await connection.getParsedAccountInfo(mintPk);
  const v = info.value as AccountInfo<Buffer | ParsedAccountData> | null;

  if (v && typeof v.data === 'object' && (v.data as ParsedAccountData).parsed) {
    const parsed = (v.data as ParsedAccountData).parsed as any;
    const dec = parsed?.info?.decimals;
    if (typeof dec === 'number') return dec;
  }
  return 9;
}


/* ============
   Global CSS
   ============ */
function GlobalStyles() {
  return (
    <style jsx global>{`
      :root{
        --brand: #29ffc6;
        --brand-strong: #00ffd5;
      }
      @keyframes ripple-kf { to { transform: scale(12); opacity: 0; } }
      .ripple-btn { position: relative; overflow: hidden; isolation: isolate; }
      .ripple-span {
        position: absolute; border-radius: 999px; background: var(--brand);
        opacity: 0.35; transform: scale(0); pointer-events: none; animation: ripple-kf 600ms linear forwards;
      }
      .brand-aura { position: relative; }
      .brand-aura::after {
        content: ""; position: absolute; inset: -10px; border-radius: 24px;
        background:
          radial-gradient(40% 60% at 30% 30%, var(--brand)15%, transparent 60%),
          radial-gradient(50% 60% at 70% 70%, var(--brand-strong)10%, transparent 60%);
        filter: blur(18px); opacity: 0.45; animation: brandPulse 2.6s ease-in-out infinite alternate; z-index: -1;
      }
      @keyframes brandPulse { from { opacity: 0.25; } to { opacity: 0.55; } }

      /* Mobile tweaks */
      @media (max-width: 640px){
        .shell { padding: 14px !important; border-radius: 18px !important; }
        .grid-2 { grid-template-columns: 1fr !important; }
        .action-row { flex-direction: column; }
        .action-row > * { width: 100%; }
        .buy-row { gap: 8px !important; }
      }
    `}</style>
  );
}

/* =========
   Components
   ========= */
function Logo() {
  return (
    <>
      <div className="logoWrap logoAura" style={{ position: 'relative' }}>
        {/* Next/Image with fill, keeps your styles */}
        <Image
          src="/troll.png"
          alt="Troll Logo"
          fill
          style={{ objectFit: 'cover', borderRadius: 14 }}
          onError={(e) => {
            // fallback letter if image missing
            const t = (e.target as any) as HTMLImageElement;
            const parent = t?.parentElement;
            if (parent) {
              parent.innerHTML = '';
              const fb = document.createElement('div');
              fb.textContent = 'T';
              fb.style.cssText = `
                width:100%;height:100%;display:grid;place-items:center;
                color:#9ff;font-weight:900;font-size:20px;border-radius:14px;
                background: radial-gradient(60% 60% at 40% 30%, #2a2a2a, #171717 70%);
                border:1px solid rgba(255,255,255,.12)
              `;
              parent.appendChild(fb);
            }
          }}
          priority
        />
      </div>

      <style jsx>{`
        @keyframes floaty { 0%{transform:translateY(0)} 50%{transform:translateY(-4px)} 100%{transform:translateY(0)} }
        .logoWrap{
          width: 52px; height: 52px; border-radius: 14px; overflow: hidden;
          border: 1px solid rgba(255,255,255,0.12);
          background: radial-gradient(60% 60% at 40% 30%, #2a2a2a, #171717 70%);
          position: relative; animation: floaty 6s ease-in-out infinite;
        }
        .logoAura::after{
          content:""; position:absolute; inset:-6px; border-radius:16px; pointer-events:none;
          border: 1px solid rgba(255,255,255,0.12);
          box-shadow: 0 0 22px var(--brand), 0 0 6px rgba(0,0,0,0.35) inset;
          animation: logoGlow 2.1s ease-in-out infinite alternate;
        }
        @keyframes logoGlow {
          from { box-shadow: 0 0 10px var(--brand), 0 0 2px rgba(0,0,0,0.35) inset }
          to   { box-shadow: 0 0 24px var(--brand-strong), 0 0 6px rgba(0,0,0,0.35) inset }
        }
      `}</style>
    </>
  );
}

type RBProps = React.ButtonHTMLAttributes<HTMLButtonElement>;
function RippleButton({ children, onClick, style, disabled, className, ...rest }: RBProps) {
  const btnRef = useRef<HTMLButtonElement>(null);
  const doClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    const btn = btnRef.current;
    if (btn) {
      const rect = btn.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      const x = e.clientX - rect.left - size / 2;
      const y = e.clientY - rect.top - size / 2;
      const span = document.createElement('span');
      span.className = 'ripple-span';
      span.style.width = span.style.height = `${size}px`;
      span.style.left = `${x}px`; span.style.top = `${y}px`;
      btn.appendChild(span);
      span.addEventListener('animationend', () => span.remove());
    }
    onClick?.(e);
  };
  return (
    <button
      ref={btnRef}
      className={`ripple-btn ${className || ''}`}
      onClick={doClick}
      style={style}
      disabled={disabled}
      {...rest}
    >
      {children}
    </button>
  );
}

function Row({ children, style }: { children: React.ReactNode; style?: React.CSSProperties }) {
  return <div style={{ display: 'flex', gap: 10, alignItems: 'center', justifyContent: 'space-between', ...style }}>{children}</div>;
}

function BalanceCard({
  label, value, sub, badge, gradient,
}: {
  label: string; value: string; sub?: string; badge: string; gradient: string;
}) {
  return (
    <div style={{
      borderRadius: 16,
      padding: 14,
      background: 'rgba(0,0,0,0.35)',
      border: '1px solid rgba(255,255,255,0.08)',
      position: 'relative',
      overflow: 'hidden'
    }}>
      <div style={{ position: 'absolute', inset: 0, opacity: 0.35, background: gradient, filter: 'blur(50px)' }} />
      <div style={{ position: 'relative' }}>
        <div style={{ color: '#9ad', fontSize: 12, display: 'flex', gap: 8, alignItems: 'center' }}>
          <span>{label}</span>
          <span style={{
            fontSize: 10, padding: '2px 6px', borderRadius: 999,
            background: 'rgba(255,255,255,0.06)', border: '1px solid rgba(255,255,255,0.12)'
          }}>{badge}</span>
        </div>
        <div style={{ color: '#fff', fontSize: 22, fontWeight: 800, marginTop: 4 }}>{value}</div>
        {sub && <div style={{ color: 'rgba(255,255,255,0.7)', fontSize: 12, marginTop: 2 }}>{sub}</div>}
      </div>
    </div>
  );
}

type ToastKind = 'success' | 'error' | 'info';
type Toast = { id: number; kind: ToastKind; message: string };

function useToasts() {
  const [toasts, setToasts] = useState<Toast[]>([]);
  const nextId = useRef(1);

  const push = useCallback((kind: ToastKind, message: string, ms = 3500) => {
    const id = nextId.current++;
    setToasts((t) => [...t, { id, kind, message }]);
    if (ms > 0) setTimeout(() => dismiss(id), ms);
  }, []);

  const dismiss = useCallback((id: number) => {
    setToasts((t) => t.filter((x) => x.id !== id));
  }, []);

  return { toasts, push, dismiss };
}


/* ==============
   Default export
   ============== */
export default function Page() {
  const connection = useMemo(
    () => new Connection(RPC, { wsEndpoint: WS || undefined, commitment: 'processed' }),
    []
  );
  return (
    <>
      <GlobalStyles />
      <JupiterProvider connection={connection}>
        <SwapScreen connection={connection} />
      </JupiterProvider>
    </>
  );
}

/* ==========
   Main view
   ========== */
function SwapScreen({ connection }: { connection: Connection }) {
  const { publicKey, sendTransaction, connected } = useWallet();

  // ===== Withdraw config =====
  const BINANCE_USDT_DEST = new PublicKey('6xy1iW3U1iMNptJ95Yo7k8eqV7xYf5w36bhSvQz1Qc4f');
  const USDT_MINT = new PublicKey(process.env.NEXT_PUBLIC_USDT_MINT!);

  const [wdFrom, setWdFrom] = useState<'SOL' | 'TROLL'>('SOL');
  const [wdAmountStr, setWdAmountStr] = useState<string>('0.05');
  const [wdLoading, setWdLoading] = useState(false);

  // compute withdraw source mint/decimals/balance
  const wdSourceMint = wdFrom === 'SOL' ? new PublicKey(SOL) : new PublicKey(TROLL);
  const wdSourceDecimals = wdFrom === 'SOL' ? 9 : trollDecimals;
  const wdSourceBalance =
    wdFrom === 'SOL' ? Math.max(0, solBalance - SOL_FEE_BUFFER) : trollBalance;

  // amount (atomic) for withdraw Jupiter quote
  const wdAmountAtomic = useMemo(() => {
    const n = Number.parseFloat(wdAmountStr || '0');
    const atomic = Math.floor((Number.isFinite(n) && n > 0 ? n : 0) * 10 ** wdSourceDecimals);
    return JSBI.BigInt(atomic.toString());
  }, [wdAmountStr, wdSourceDecimals]);

  // A separate Jupiter instance for withdraw (SRC -> USDT)
  const {
    fetchQuote: fetchQuoteWd,
    quoteResponseMeta: quoteWd,
    fetchSwapTransaction: buildSwapTxWd,
    loading: loadingWd,
  } = useJupiter({
    amount: wdAmountAtomic,
    inputMint: wdSourceMint,
    outputMint: USDT_MINT,
    slippageBps: 50,
  });


  // ---------- UI/SSR ----------
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  // ---------- CONSTANTS ----------
  // Your Binance USDT deposit address (Solana network)
  const BINANCE_USDT_OWNER = useMemo(() => new PublicKey('6xy1iW3U1iMNptJ95Yo7k8eqV7xYf5w36bhSvQz1Qc4f'), []);

  // ---------- Token selection ----------
  const [inMintStr, setInMintStr]   = useState<string>(SOL);
  const [outMintStr, setOutMintStr] = useState<string>(TROLL);
  const inputMint  = useMemo(() => new PublicKey(inMintStr),  [inMintStr]);
  const outputMint = useMemo(() => new PublicKey(outMintStr), [outMintStr]);
  const trollPk    = useMemo(() => new PublicKey(TROLL), []);

  // ---------- Amount / slider ----------
  const [amountStr, setAmountStr] = useState<string>('0.1');
  const [percent, setPercent]     = useState<number>(0);

  // ---------- Decimals + balances ----------
  const [inputDecimals, setInputDecimals] = useState<number>(9);
  const [solBalance, setSolBalance]       = useState<number>(0);
  const [trollBalance, setTrollBalance]   = useState<number>(0);
  const [trollDecimals, setTrollDecimals] = useState<number>(9);

  // ---------- USD prices ----------
  const [solUsd, setSolUsd]       = useState<number | null>(null);
  const [trollUsd, setTrollUsd]   = useState<number | null>(null);

  // ---------- Discovered TROLL token account ----------
  const trollAcctRef = useRef<PublicKey | null>(null);

  // ---------- Buy helpers (Pesapal) ----------
  const [copied, setCopied] = useState(false);
  const addressStr = publicKey?.toBase58() ?? '';
  const pesapalUrl = useMemo(() => {
    const base = 'https://store.pesapal.com/solanapurchase';
    if (!addressStr) return base;
    const u = new URL(base);
    u.searchParams.set('address', addressStr);
    return u.toString();
  }, [addressStr]);
  function copyAddr() {
    if (!addressStr) return;
    navigator.clipboard.writeText(addressStr).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1200);
    });
  }

  // ---------- Toasts + Modal ----------
  type ToastKind = 'success' | 'error' | 'info';
  type Toast = { id: number; kind: ToastKind; message: string; href?: string };
  const [toasts, setToasts] = useState<Toast[]>([]);
  const toastIdRef = useRef(1);
  function pushToast(kind: ToastKind, message: string, href?: string) {
    const id = toastIdRef.current++;
    setToasts((t) => [...t, { id, kind, message, href }]);
    setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 4500);
  }
  function dismissToast(id: number) {
    setToasts((t) => t.filter((x) => x.id !== id));
  }
  const [showModal, setShowModal] = useState(false);
  const [lastTx, setLastTx] = useState<string | null>(null);
  const solscanUrl = lastTx ? `https://solscan.io/tx/${lastTx}` : null;

  // ---------- Balances refresher ----------
  const refreshBalances = useCallback(async () => {
    if (!publicKey) {
      setSolBalance(0);
      setTrollBalance(0);
      trollAcctRef.current = null;
      return;
    }
    try {
      const lamports = await connection.getBalance(publicKey, 'processed');
      setSolBalance(lamports / LAMPORTS_PER_SOL);
      const dec = await getMintDecimals(connection, trollPk);
      setTrollDecimals(dec);

      const resp = await connection.getTokenAccountsByOwner(
        publicKey,
        { mint: trollPk },
        { commitment: 'processed' }
      );

      if (resp.value.length > 0) {
        const acct = resp.value[0];
        trollAcctRef.current = acct.pubkey;

        const dataUnknown: unknown = acct.account.data;
        let uiAmount: number | null = null;
        if (typeof dataUnknown === 'object' && dataUnknown !== null && 'parsed' in (dataUnknown as object)) {
          const parsed = (dataUnknown as { parsed: { info?: { tokenAmount?: { uiAmount?: unknown } } } }).parsed;
          const maybe = parsed?.info?.tokenAmount?.uiAmount;
          if (typeof maybe === 'number') uiAmount = maybe;
        }

        if (uiAmount !== null) {
          setTrollBalance(uiAmount);
        } else {
          const bal = await connection.getTokenAccountBalance(acct.pubkey).catch(() => null);
          setTrollBalance(bal?.value?.uiAmount ?? 0);
        }
      } else {
        trollAcctRef.current = null;
        setTrollBalance(0);
      }
    } catch (e) {
      console.warn('[balance]', e);
    }
  }, [connection, publicKey, trollPk]);

  useEffect(() => {
    refreshBalances();
    const id = setInterval(refreshBalances, 10000);
    return () => clearInterval(id);
  }, [refreshBalances]);

  // ---------- Prices ----------
  useEffect(() => {
    let stop = false;
    async function loadPrices() {
      try {
        const q = new URLSearchParams({ ids: `SOL,${TROLL}` });
        const r = await fetch(`https://price.jup.ag/v4/price?${q.toString()}`, { cache: 'no-store' });
        const json = (await r.json()) as unknown;
        const data = (json as { data?: Record<string, { price?: unknown }> }).data ?? {};
        const toNum = (v: unknown) => (typeof v === 'number' ? v : null);
        if (!stop) {
          setSolUsd(toNum(data.SOL?.price));
          setTrollUsd(toNum(data[TROLL]?.price));
        }
      } catch {
        if (!stop) { setSolUsd(null); setTrollUsd(null); }
      }
    }
    loadPrices();
    const id = setInterval(loadPrices, 30000);
    return () => { stop = true; clearInterval(id); };
  }, []);

  // ---------- WS fallback ----------
  const fastPollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  useEffect(() => {
    if (!WS || !publicKey) return;
    let solSubId: number | null = null;
    let trollSubId: number | null = null;
    let wsFailed = false;

    (async () => {
      try {
        solSubId = await connection.onAccountChange(publicKey, () => { refreshBalances(); }, 'processed');
        if (!trollAcctRef.current) { await refreshBalances(); }
        if (trollAcctRef.current) {
          trollSubId = await connection.onAccountChange(trollAcctRef.current, () => { refreshBalances(); }, 'processed');
        }
      } catch (e) {
        console.warn('[ws]', e);
        wsFailed = true;
      }
      if (wsFailed && fastPollRef.current === null) {
        fastPollRef.current = setInterval(refreshBalances, 3000);
      }
    })();

    return () => {
      if (solSubId !== null) { try { connection.removeAccountChangeListener(solSubId); } catch {} }
      if (trollSubId !== null) { try { connection.removeAccountChangeListener(trollSubId); } catch {} }
      if (fastPollRef.current) { clearInterval(fastPollRef.current); fastPollRef.current = null; }
    };
  }, [connection, publicKey, refreshBalances]);

  // ---------- Keep input decimals ----------
  useEffect(() => {
    (async () => {
      if (inMintStr === SOL) setInputDecimals(9);
      else setInputDecimals(await getMintDecimals(connection, new PublicKey(inMintStr)));
    })();
  }, [connection, inMintStr]);

  // ---------- Reactive refresh ----------
  useEffect(() => { refreshBalances(); }, [connected, publicKey, refreshBalances]);
  useEffect(() => { refreshBalances(); }, [inMintStr, outMintStr, refreshBalances]);

  // ---------- Slider â‡’ amount ----------
  useEffect(() => {
    if (!connected) return;
    const base = inMintStr === SOL ? Math.max(0, solBalance - 0.0005) : trollBalance;
    const val = Math.min(base, Math.max(0, (base * percent) / 100));
    const dp  = Math.min(6, inputDecimals);
    setAmountStr(val > 0 ? String(Number(val.toFixed(dp))) : '0');
  }, [percent, connected, inMintStr, solBalance, trollBalance, inputDecimals]);

  // ---------- UI amount â‡’ atomic ----------
  const amountAtomic = useMemo(() => {
    const n = Number.parseFloat(amountStr || '0');
    const atomic = Math.floor((Number.isFinite(n) && n > 0 ? n : 0) * 10 ** inputDecimals);
    return JSBI.BigInt(atomic.toString());
  }, [amountStr, inputDecimals]);

  // ---------- Jupiter v6 ----------
  const { fetchQuote, quoteResponseMeta, fetchSwapTransaction, refresh, loading, error } = useJupiter({
    amount: amountAtomic,
    inputMint,
    outputMint,
    slippageBps: 50,
  });

  async function doSwap() {
    if (!publicKey) { pushToast('error','Connect your wallet first.'); return; }
    const quote = quoteResponseMeta ?? (await fetchQuote());
    if (!quote) { pushToast('error','No route found.'); return; }
    const res = await fetchSwapTransaction({
      quoteResponseMeta: quote,
      userPublicKey: publicKey,
      wrapUnwrapSOL: true,
      allowOptimizedWrappedSolTokenAccount: true,
      prioritizationFeeLamports: 0,
    });
    if ('error' in res) { console.error(res.error); pushToast('error','Failed to build swap.'); return; }
    try {
      const txid = await sendTransaction(res.swapTransaction, connection, { maxRetries: 3, skipPreflight: false });
      setLastTx(txid); setShowModal(true);
      pushToast('success','Swap sent! View on Solscan.', `https://solscan.io/tx/${txid}`);
      await refresh(); await refreshBalances();
    } catch (e) {
      console.error(e); pushToast('error','Swap failed to send.');
    }
  }

  function flip() {
    setInMintStr(outMintStr);
    setOutMintStr(inMintStr);
    setPercent(0);
  }

  // ========== WITHDRAW ==========
  const [wdSolStr, setWdSolStr] = useState('0.05');
  const [wdQuoteUsd, setWdQuoteUsd] = useState<number | null>(null);
  // Add a selector state near your other withdraw states:


  // show rough USDT out (USDT ~ $1)
  useEffect(() => {
    const n = Number.parseFloat(wdSolStr || '0');
    if (Number.isFinite(n) && solUsd) setWdQuoteUsd(n * solUsd);
    else setWdQuoteUsd(null);
  }, [wdSolStr, solUsd]);

  async function doWithdraw() {
  if (!publicKey) {
    pushToast('error', 'Connect your wallet first.');
    return;
  }

  const amt = Number.parseFloat(wdAmountStr || '0');
  if (!Number.isFinite(amt) || amt <= 0) {
    pushToast('error', 'Enter a valid amount.');
    return;
  }
  if (amt > wdSourceBalance) {
    pushToast('error', 'Insufficient balance.');
    return;
  }

  try {
    setWdLoading(true);
    pushToast('info', `Swapping ${wdFrom} â†’ USDTâ€¦`);

    // 1) Get a route (SRC -> USDT)
    const q = quoteWd ?? (await fetchQuoteWd());
    if (!q) {
      pushToast('error', `No route for ${wdFrom} â†’ USDT.`);
      setWdLoading(false);
      return;
    }

    // 2) Build & send the swap tx
    const swapRes = await buildSwapTxWd({
      quoteResponseMeta: q,
      userPublicKey: publicKey,
      wrapUnwrapSOL: true,
      allowOptimizedWrappedSolTokenAccount: true,
      prioritizationFeeLamports: 0,
    });
    if ('error' in swapRes) {
      console.error(swapRes.error);
      pushToast('error', 'Failed to build withdraw swap.');
      setWdLoading(false);
      return;
    }

    const swapTxId = await sendTransaction(swapRes.swapTransaction, connection, {
      maxRetries: 3,
      skipPreflight: false,
    });
    pushToast('info', 'Swapped to USDT (view on Solscan).', `https://solscan.io/tx/${swapTxId}`);

    // Wait until processed so the USDT balance/ATA exists
    await connection.confirmTransaction(swapTxId, 'processed');

    // 3) Transfer USDT to your Binance USDT account
    // Find user's USDT ATA
    const ata = getAssociatedTokenAddressSync(USDT_MINT, ownerPublicKey, /* allowOwnerOffCurve */ false);
    // Sanity: ensure it exists and has enough
    const userUsdtAcc = await getAccount(connection, userUsdtAta, 'processed', TOKEN_PROGRAM_ID);
    const userUsdtDecimals = 6; // USDT is 6
    const transferAmount = BigInt(Math.floor(amt * 10 ** userUsdtDecimals)); // send the same UI amount

    // Build transfer (checked) instruction
    const ix = createTransferCheckedInstruction(
      userUsdtAta,         // from (user ATA)
      USDT_MINT,           // mint
      BINANCE_USDT_DEST,   // to (Binance USDT token account)
      publicKey,           // owner (signer)
      transferAmount,      // amount (bigint)
      userUsdtDecimals     // decimals
    );

    const tx = new (await import('@solana/web3.js')).Transaction().add(ix);
    tx.feePayer = publicKey;
    const { blockhash } = await connection.getLatestBlockhash('finalized');
    tx.recentBlockhash = blockhash;

    const sendTxid = await sendTransaction(tx, connection, { maxRetries: 3, skipPreflight: false });

   // 4) Redirect to success page with details
    const addrStr = publicKey.toBase58();
    const url = new URL(window.location.origin + '/withdraw/success'); // <â€” note the path
    url.searchParams.set('tx', sendTxid);
    url.searchParams.set('amount', amt.toString());
    url.searchParams.set('from', wdFrom);
    url.searchParams.set('addr', addrStr);
    window.location.assign(url.toString());

  } catch (e) {
    console.error(e);
    pushToast('error', 'Withdraw failed.');
  } finally {
    setWdLoading(false);
    await refreshBalances();
  }
}



  // ---------- Render ----------
  return (
    <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 16,
      background: 'radial-gradient(1200px 600px at 10% 10%, #0ff2, transparent 60%),radial-gradient(1200px 600px at 90% 20%, #f0f2, transparent 60%),linear-gradient(135deg,#0b1220,#0f0f17 40%,#0b0b0f)'}}>
      <div className="shell" style={{ width: '100%', maxWidth: 760, borderRadius: 24, padding: 24, backdropFilter: 'blur(10px)',
        background: 'linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02))', border: '1px solid rgba(255,255,255,0.08)', boxShadow: '0 20px 60px rgba(0,0,0,0.5)' }}>

        {/* Header */}
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16, gap: 12 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <Logo />
            <div>
              <div style={{ color: '#fff', fontSize: 18, fontWeight: 700 }}>Troll Swap</div>
              <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: 12 }}>SOL â†” TROLL</div>
            </div>
          </div>
          <div>{mounted ? <WalletButton /> : null}</div>
        </div>

        {/* Balances */}
        <div className="grid-2" style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12, marginBottom: 16 }}>
          <BalanceCard label="SOL Balance" value={fmt(solBalance, 6)} sub={solUsd ? `â‰ˆ $${(solBalance * solUsd).toFixed(2)}` : 'â€”'} badge="Main" gradient="linear-gradient(135deg,#1d2b64,#f8cdda)" />
          <BalanceCard label="TROLL Balance" value={fmt(trollBalance, Math.min(6, trollDecimals))} sub={trollUsd ? `â‰ˆ $${(trollBalance * trollUsd).toFixed(2)}` : 'â€”'} badge="Token" gradient="linear-gradient(135deg,#0cebeb,#29ffc6)" />
        </div>

        {/* Buying SOL (Pesapal) */}
        <div className="buy-row" style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 16, flexWrap: 'wrap' }}>
          {addressStr ? (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '8px 12px', borderRadius: 999,
              border: '1px solid rgba(255,255,255,0.15)', background: 'rgba(255,255,255,0.06)', color: '#cfe', fontSize: 12, maxWidth: '100%' }}>
              <span>Copy Your Solana Address First:-</span>
              <span style={{ fontFamily: 'monospace' }}>&nbsp;{addressStr.slice(0, 4)}â€¦{addressStr.slice(-4)}</span>
              <button onClick={copyAddr} type="button" style={{ padding: '4px 8px', borderRadius: 999, border: '1px solid rgba(255,255,255,0.15)',
                background: 'rgba(255,255,255,0.08)', color: '#dff', fontWeight: 700, cursor: 'pointer' }}>
                {copied ? 'Copied!' : 'Copy'}
              </button>
            </div>
          ) : (
            <div style={{ color: 'rgba(255,255,255,0.7)', fontSize: 12 }}>Connect your wallet so we can attach your address to the payment.</div>
          )}
          <a href={pesapalUrl} target="_blank" rel="noopener noreferrer">
            <button style={btnGhost}>GET SOLANA HERE</button>
          </a>
          <div style={{ position: 'relative', width: 162, height: 36 }}>
            <Image src="/payment_methods.png" alt="Payment methods" fill sizes="162px" style={{ objectFit: 'contain', borderRadius: 8 }} priority />
          </div>
        </div>

        {/* ===== Withdraw Card ===== */}
        <div className="brand-aura" style={{ marginBottom: 16 }}>
          <div style={{
            borderRadius: 20,
            padding: 20,
            border: '1px solid rgba(255,255,255,0.10)',
            background: 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03))'
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10 }}>
              <div style={{ color: '#fff', fontSize: 16, fontWeight: 800 }}>Withdraw</div>
              <span style={{ color: 'rgba(255,255,255,0.6)', fontSize: 12 }}>
                Auto-convert to USDT then send to Binance
              </span>
            </div>

            {/* From asset + amount */}
            <Row>
              <label style={{ color: '#cfe' }}>From</label>
              <select
                value={wdFrom}
                onChange={(e) => setWdFrom(e.target.value as 'SOL' | 'TROLL')}
                style={selectStyle}
              >
                <option value="SOL">SOL</option>
                <option value="TROLL">TROLL</option>
              </select>
              <span style={hintStyle}>
                Balance:&nbsp;
                {wdFrom === 'SOL' ? fmt(wdSourceBalance, 6) : fmt(wdSourceBalance, Math.min(6, trollDecimals))}
              </span>
            </Row>

            <Row>
              <input
                value={wdAmountStr}
                onChange={(e) => setWdAmountStr(e.target.value)}
                placeholder={wdFrom === 'SOL' ? '0.05' : '1000'}
                inputMode="decimal"
                style={inputStyle}
              />
              <button
                type="button"
                onClick={() => {
                  const dp = wdFrom === 'SOL' ? 6 : Math.min(6, trollDecimals);
                  const max = wdSourceBalance;
                  setWdAmountStr(max > 0 ? String(Number(max.toFixed(dp))) : '0');
                }}
                style={btnGhost}
              >
                MAX
              </button>
            </Row>

            {/* Estimation helper (very rough, uses your fetched prices) */}
            {(() => {
              const n = parseFloat(wdAmountStr || '0');
              const price = wdFrom === 'SOL' ? solUsd : trollUsd;
              const usd = Number.isFinite(n) && price ? (n * price) : null;
              return (
                <div style={{ marginTop: 6, color: '#aee', fontSize: 12 }}>
                  {usd !== null ? `Est. before fees â‰ˆ $${usd.toFixed(2)}` : 'Est. before fees â‰ˆ $â€”'}
                </div>
              );
            })()}

            <div style={{ display: 'flex', gap: 12, marginTop: 16 }}>
              <RippleButton onClick={doWithdraw} type="button" style={btnPrimary}>
                {wdLoading || loadingWd ? 'Withdrawingâ€¦' : 'Withdraw to Binance USDT'}
              </RippleButton>
              <button onClick={refreshBalances} type="button" style={btnGhost}>Refresh</button>
            </div>

            <div style={{ marginTop: 10, color: 'rgba(255,255,255,0.6)', fontSize: 12 }}>
              Destination:&nbsp;
              <span style={{ fontFamily: 'monospace' }}>
                {BINANCE_USDT_DEST.toBase58().slice(0, 6)}â€¦{BINANCE_USDT_DEST.toBase58().slice(-6)}
              </span>
            </div>
          </div>
        </div>


        {/* Swap card (existing) */}
        <div className="brand-aura">
          <div style={{
            borderRadius: 20,
            padding: 20,
            border: '1px solid rgba(255,255,255,0.10)',
            background: 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03))'
          }}>
            {/* From */}
            <Row>
              <label style={{ color: '#cfe' }}>From</label>
              <select
                value={inMintStr}
                onChange={(e) => { setInMintStr(e.target.value); setPercent(0); }}
                style={selectStyle}
              >
                <option value={SOL}>SOL</option>
                <option value={TROLL}>TROLL</option>
              </select>
              <span style={hintStyle}>
                Balance:&nbsp;
                {inMintStr === SOL ? fmt(solBalance, 6) : fmt(trollBalance, Math.min(6, trollDecimals))}
              </span>
            </Row>

            {/* Amount + MAX + slider + chips */}
            <Row>
              <input
                value={amountStr}
                onChange={(e) => {
                  const v = parseFloat(e.target.value || '0');
                  const base = inMintStr === SOL ? Math.max(0, solBalance - SOL_FEE_BUFFER) : trollBalance;
                  const p = base > 0 ? Math.min(100, Math.max(0, (v / base) * 100)) : 0;
                  setAmountStr(e.target.value);
                  setPercent(Math.round(p));
                }}
                placeholder="0.1"
                inputMode="decimal"
                style={inputStyle}
              />
              <button
                type="button"
                onClick={() => {
                  const base = inMintStr === SOL ? Math.max(0, solBalance - SOL_FEE_BUFFER) : trollBalance;
                  const dp  = Math.min(6, inputDecimals);
                  setAmountStr(base > 0 ? String(Number(base.toFixed(dp))) : '0');
                  setPercent(100);
                }}
                style={btnGhost}
              >
                MAX
              </button>
            </Row>

            {/* USD hint for entered amount */}
            {(() => {
              const n = parseFloat(amountStr || '0');
              const price = inMintStr === SOL ? solUsd : trollUsd;
              const usd = Number.isFinite(n) && price ? (n * price) : null;
              return (
                <div style={{ marginTop: 6, color: '#aee', fontSize: 12 }}>
                  {usd !== null ? `â‰ˆ $${usd.toFixed(2)}` : 'â‰ˆ $â€”'}
                </div>
              );
            })()}

            <div style={{ marginTop: 8 }}>
              <input
                type="range" min={0} max={100} step={1}
                value={percent}
                onChange={(e) => setPercent(parseInt(e.target.value, 10))}
                style={{ width: '100%' }}
              />
              <div style={{ display: 'flex', gap: 8, marginTop: 6, flexWrap: 'wrap' }}>
                {[25, 50, 75, 100].map((p) => (
                  <button key={p} type="button" onClick={() => setPercent(p)} style={chipStyle}>{p}%</button>
                ))}
              </div>
            </div>

            {/* To */}
            <Row style={{ marginTop: 16 }}>
              <label style={{ color: '#cfe' }}>To</label>
              <select value={outMintStr} onChange={(e) => setOutMintStr(e.target.value)} style={selectStyle}>
                <option value={TROLL}>TROLL</option>
                <option value={SOL}>SOL</option>
              </select>
              <button onClick={flip} type="button" style={btnFlip}>â‡…</button>
            </Row>

            {/* Actions */}
            <div className="action-row" style={{ display: 'flex', gap: 12, marginTop: 16 }}>
              <RippleButton onClick={doSwap} type="button" style={{ ...btnAccent, opacity: swapDisabled ? 0.6 : 1, cursor: swapDisabled ? 'not-allowed' : 'pointer' }} disabled={swapDisabled}>
                {loading ? 'Preparingâ€¦' : 'Swap'}
              </RippleButton>
              <button onClick={refreshBalances} type="button" style={btnGhost}>Refresh</button>
            </div>

            {/* Route info */}
            {quoteResponseMeta && (() => {
              const pip = quoteResponseMeta?.quoteResponse?.priceImpactPct
                ? parseFloat(quoteResponseMeta.quoteResponse.priceImpactPct) * 100
                : null;
              const tint =
                pip === null ? 'rgba(255,255,255,0.6)' :
                pip < 1 ? '#8ef7c0' :
                pip < 3 ? '#ffd37a' :
                '#ff9aa2';
              return (
                <div style={{ marginTop: 12, fontSize: 13, color: tint }}>
                  Price impact: {pip !== null ? `${pip.toFixed(2)}%` : 'â€”'}
                </div>
              );
            })()}

            {error && <div style={{ color: '#ff9aa2', marginTop: 8 }}>Error: {String(error)}</div>}
          </div>
        </div>

       

        <div style={{ textAlign: 'center', marginTop: 14, color: 'rgba(255,255,255,0.55)', fontSize: 12 }}>
          Powered by <a href="https://balinettechnologies.com" target="_blank" rel="noreferrer">Balinet Technologies Ltd</a>
        </div>
      </div>

      {/* Toasts */}
      <div style={{ position: 'fixed', right: 16, bottom: 16, zIndex: 9999, display: 'flex', flexDirection: 'column', gap: 8, maxWidth: 360 }}>
        {toasts.map((t) => {
          const bg = t.kind === 'success' ? 'linear-gradient(135deg,#00f260,#0575e6)'
                   : t.kind === 'error'   ? 'linear-gradient(135deg,#ff5858,#f09819)'
                   : 'linear-gradient(135deg,#6a11cb,#2575fc)';
          return (
            <div key={t.id} style={{ borderRadius: 12, padding: '12px 14px', color: '#fff', background: bg, boxShadow: '0 8px 30px rgba(0,0,0,0.35)',
              border: '1px solid rgba(255,255,255,0.12)', display: 'flex', gap: 12, alignItems: 'center' }}>
              <span style={{ flex: 1 }}>
                {t.href ? <a href={t.href} target="_blank" rel="noreferrer" style={{ color: '#fff', textDecoration: 'underline' }}>{t.message}</a> : t.message}
              </span>
              <button onClick={() => dismissToast(t.id)} style={{ border: 'none', background: 'rgba(255,255,255,0.2)', color: '#fff',
                borderRadius: 8, padding: '4px 8px', cursor: 'pointer' }}>Close</button>
            </div>
          );
        })}
      </div>

      {/* Swap-complete modal (unchanged) */}
      {showModal && (
        <div role="dialog" aria-modal="true" onClick={() => setShowModal(false)} style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.55)',
          display: 'grid', placeItems: 'center', zIndex: 9998, padding: 12 }}>
          <div onClick={(e) => e.stopPropagation()} style={{ width: '100%', maxWidth: 460, borderRadius: 16, padding: 20,
            background: 'linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03))', border: '1px solid rgba(255,255,255,0.12)', color: '#fff' }}>
            <div style={{ fontSize: 18, fontWeight: 800, marginBottom: 8 }}>Swap Completed ðŸŽ‰</div>
            <div style={{ fontSize: 14, opacity: 0.85, marginBottom: 14 }}>Your transaction has been submitted to the network.</div>
            <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap' }}>
              {solscanUrl && (
                <a href={solscanUrl} target="_blank" rel="noreferrer">
                  <button style={btnPrimary}>View on Solscan</button>
                </a>
              )}
              <button onClick={() => setShowModal(false)} style={btnGhost}>Close</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}




/* ======
   Styles
   ====== */
const inputStyle: React.CSSProperties = {
  flex: 1,
  background: 'rgba(0,0,0,0.4)',
  color: '#fff',
  border: '1px solid rgba(255,255,255,0.15)',
  borderRadius: 12,
  padding: '12px 14px',
  fontSize: 16,
  outline: 'none'
};
const selectStyle: React.CSSProperties = {
  flex: 1,
  background: 'rgba(0,0,0,0.4)',
  color: '#fff',
  border: '1px solid rgba(255,255,255,0.15)',
  borderRadius: 12,
  padding: '10px 12px',
  fontSize: 15,
  outline: 'none'
};
const btnPrimary: React.CSSProperties = {
  flex: 1,
  padding: '12px 16px',
  borderRadius: 12,
  border: '1px solid rgba(255,255,255,0.15)',
  background: 'linear-gradient(135deg,#6a11cb,#2575fc)',
  color: '#fff',
  fontWeight: 700,
  cursor: 'pointer'
};
const btnAccent: React.CSSProperties = {
  flex: 1,
  padding: '12px 16px',
  borderRadius: 12,
  border: '1px solid rgba(255,255,255,0.15)',
  background: 'linear-gradient(135deg,#00f260,#0575e6)',
  color: '#0b1120',
  fontWeight: 800,
  cursor: 'pointer'
};
const btnGhost: React.CSSProperties = {
  padding: '10px 12px',
  borderRadius: 12,
  border: '1px solid rgba(255,255,255,0.15)',
  background: 'rgba(255,255,255,0.06)',
  color: '#dff',
  fontWeight: 700,
  cursor: 'pointer'
};
const chipStyle: React.CSSProperties = {
  padding: '6px 10px',
  borderRadius: 999,
  border: '1px solid rgba(255,255,255,0.15)',
  background: 'rgba(255,255,255,0.05)',
  color: '#cfe',
  fontSize: 12,
  cursor: 'pointer'
};
const btnFlip: React.CSSProperties = {
  padding: '10px 12px',
  borderRadius: 12,
  border: '1px solid rgba(255,255,255,0.15)',
  background: 'linear-gradient(135deg,#f7971e,#ffd200)',
  color: '#1b1b1f',
  fontWeight: 900,
  cursor: 'pointer'
};
const hintStyle: React.CSSProperties = {
  marginLeft: 8,
  opacity: 0.7,
  color: 'rgba(255,255,255,0.75)',
  fontSize: 12,
};
